/*
 * Created on 04.07.2004
 * Last modified on 14.07.2004
 *
 * Ayirah - a Java (tm)-based Roleplaying Game 
 * Copyright (C) 2003 Wolfgang Keller
 * Contact: http://ayirah.berlios.de | mail.wolfgang.keller@web.de
 * 
 * This program is free software; you can 
 * redistribute it and/or modify it under 
 * the terms of the GNU General Public License 
 * as published by the Free Software Foundation; 
 * either version 2 of the License, or 
 * (at your option) any later version. 
 * 
 * This program is distributed in the hope 
 * that it will be useful, but WITHOUT ANY WARRANTY; 
 * without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR 
 * PURPOSE. See the GNU General Public License 
 * for more details. 
 * You should have received a copy of the 
 * GNU General Public License along with 
 * this program; if not, write to the 
 * Free Software Foundation, Inc., 
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA. 
 */

/**
 * @author Wolfgang
 */

import java.util.*;
import java.io.*;

import org.xml.sax.*;
import org.xml.sax.helpers.DefaultHandler;

import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.SAXParser;

public final class LevelLoader extends DefaultHandler {
	
	protected CoordVector actual_coords;
	protected int l, x, y;
	
	protected GameItem gi;
	protected String gi_type, gi_sub_type, gi_state, gi_name;
	protected int gi_vis_type, gi_using_directions;
	protected boolean gi_take_able, gi_walk_on_able;
	protected long gi_weight;
	
	protected HashMap hm;
	
	protected boolean inMapTile;
	
	protected LevelLoader()
	{
		hm=new HashMap();
	}
	
	public static final HashMap loadLevel(String file_name)
	{
		LevelLoader handler=new LevelLoader();
		
		SAXParserFactory factory = SAXParserFactory.newInstance();
		try {
			
			// Parse the input
			SAXParser saxParser = factory.newSAXParser();
			saxParser.parse( new File(file_name), handler);
			
		}
		catch (SAXParseException spe)
		{
			System.out.println("** Parsing error" 
					+ ", line " + spe.getLineNumber()
					+ ", uri " + spe.getSystemId());
			System.out.println("   " + spe.getMessage() );
			
//			Exception  x = spe;
//			if (spe.getException() != null)
//				x = spe.getException();
//			x.printStackTrace();
		}
		
		catch (SAXException sxe) {
			// Error generated by this application
			// (or a parser-initialization error)
			Exception  x = sxe;
			if (sxe.getException() != null)
				x = sxe.getException();
			x.printStackTrace();
			
//			Exception  ex = sxe;
//			if (sxe.getException() != null)
//				x = sxe.getException();
//			x.printStackTrace();
		}
		
		catch (Exception e)
		{
			e.printStackTrace();
		}
		
		return handler.getHashMap();
	}
	
	public HashMap getHashMap()
	{
		return hm;
	}
	
	public void startDocument()
	throws SAXException
	{
		
	}
	
	public void endDocument()
	throws SAXException
	{
		
	}
	
	public void startElement(String namespaceURI,
		String lName, // local name
		String qName, // qualified name
		Attributes attrs)
	throws SAXException
	{
		String eName = lName; // element name
		if ("".equals(eName)) eName = qName; // namespaceAware = false
		
		if (eName.equals("maptile"))
		{
			reinitCoords();
		
			if (attrs != null) {
				for (int i = 0; i < attrs.getLength(); i++) {
					String aName = attrs.getLocalName(i); // Attr name 
					if ("".equals(aName)) 
						aName = attrs.getQName(i);
						
					if (aName.equals("l"))
					{
						l=Integer.parseInt(attrs.getValue(i));
					}
					
					else if (aName.equals("x"))
					{
						x=Integer.parseInt(attrs.getValue(i));
					}
					
					else if (aName.equals("y"))
					{
						y=Integer.parseInt(attrs.getValue(i));
					}
				}
			}
			
			inMapTile=true;
			
			actual_coords=new CoordVector(l, x, y);
		}
		
		else if (eName.equals("object") && inMapTile)
		{
			reinitItem();
		
			if (attrs != null) 
			{
				for (int i = 0; i < attrs.getLength(); i++) {
					String aName = attrs.getLocalName(i); // Attr name 
					if ("".equals(aName)) 
						aName = attrs.getQName(i);
				
					if (aName.equals("type"))
					{
						gi_type=attrs.getValue(i);
					}
			
					else if (aName.equals("sub_type"))
					{
						gi_sub_type=attrs.getValue(i);
					}
		
					else if (aName.equals("state"))
					{
						gi_state=attrs.getValue(i);
					}
					
					else if (aName.equals("name"))
					{
						gi_name=attrs.getValue(i);
					}
					
					else if (aName.equals("vis_type"))
					{
						gi_vis_type=Integer.parseInt(attrs.getValue(i));
					}
					
					else if (aName.equals("using_directions"))
					{
						gi_using_directions=Integer.parseInt(attrs.getValue(i));
					}
					
					else if (aName.equals("take_able"))
					{
						gi_take_able=Boolean.getBoolean(attrs.getValue(i));
					}
					
					else if (aName.equals("walk_on_able"))
					{
						gi_walk_on_able=Boolean.getBoolean(attrs.getValue(i));
					}
					
					else if (aName.equals("weight"))
					{
						gi_weight=Long.parseLong(attrs.getValue(i));
					}
				}
			}
		
			gi=new GameItem(gi_type, gi_sub_type, gi_state, gi_name, gi_vis_type, gi_using_directions,
			gi_take_able,gi_walk_on_able, gi_weight);
		}
		
		else if (eName.equals("object") && !inMapTile)
		{
			System.out.println("<object>-Tags dürfen nur in <maptile>-Tags benutzt werden");
		}
	}
	
	public void endElement(String namespaceURI,
		String sName, // simple name
		String qName  // qualified name
		)
		throws SAXException
	{
		String eName = sName; // element name
		if ("".equals(eName)) eName = qName; // namespaceAware = false
		
		if (eName.equals("maptile"))
		{
			hm.put(actual_coords, gi);
			inMapTile=false;
		}
	}
	
	protected void reinitCoords()
	{
		actual_coords=null;
		l=0;
		x=0;
		y=0;
	}
	
	protected void reinitItem()
	{
		gi=null;
		gi_type="";
		gi_sub_type="";
		gi_state="";
		gi_name="";
		gi_vis_type=0;
		gi_using_directions=15;
		gi_take_able=false;
		gi_walk_on_able=false;
		gi_weight=0;
	}
}
